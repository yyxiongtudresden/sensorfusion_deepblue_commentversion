# comment
---
 这是对于整个包的主要comment, 主要记录学习 从零开始做自动驾驶定位(四) 遇到的问题和解答

 参考地址： https://zhuanlan.zhihu.com/p/105694269

---
**为了程序清晰，我们把前端里程计封装成一个类** 
```cpp 
class FrontEnd 
```


# 一、概述
1： 此处选用的是NDT匹配方法

2：在include和src文件夹下各建一个名为front_end的文件夹，来存储这个类的头文件和源文件。执行功能的node文件在根目录下，名为front_end_node.cpp。

所以本篇文章的重点就是介绍这三个文件了。

---

# 二、里程计模块子功能介绍

了解它的工作流程，才方便知道怎样切分更合理。

1）从接收到一帧点云开始，首先是要匹配，和地图匹配，如果它是第一帧数据，那么它就是地图，供下一帧匹配使用。

2）我们不能把每一帧匹配好的点云都加入地图，那样太大了，所以要提取关键帧，即每隔一段距离取一帧点云，用关键帧拼接成地图即可。

3）到这里，会想到一个问题，那就是地图会一直累加，那么我们一直用它匹配会导致很多不必要的计算量，所以应该还需要一个小地图，即把和当前帧一定距离范围内的关键帧找出来拼接即可，可以叫它滑窗

4）在**匹配之前**需要滤波，对点云稀疏化，不然匹配会非常慢。

5) 点云匹配还有一个特性，就是它对位姿的预测值比较敏感，所以在载体运动时，不能以它上一帧的位姿作为这一帧的预测值，可以使用IMU预测，也可以使用运动模型预测。

---

找到某一个语句在哪里 直接用VSCode的全局搜索 ctrl+Shift+F

## 1.点云匹配
 代码在 ndt_registration 中

## 2. 关键帧 --曼哈顿距离
代码在 front_node  中

红线代表曼哈顿距离，绿色代表欧氏距离，也就是直线距离，而蓝色和黄色代表等价的曼哈顿距离

<img src="doc/2021-01-31 14-17-36.png" alt="Terminator" width="40%">

## 3. 滑窗
代码在 ndt_registration 中

滑窗小地图就是所谓的local map

## 4. 点云滤波

代码在 ndt_registration 中 和 voxel_filter
点云滤波是直接采用了pcl中的voxel_filter，它的基本原理就是把三维空间划分成等尺寸的立方体格子，在一个立方体格子内最多只留一个点，这样就起到稀疏作用。

由于小地图滤波和当前帧滤波采用的格子大小不一样，所以类内为这两个功能各定义了一个滤波器。

## 5. 位姿预测
代码在 front_node  中

---
# 三. 接口

## 1. 初始位姿输入

---

# comment
---
 这是对于整个包的主要comment, 主要记录学习 从零开始做自动驾驶定位(五): 前端里程计之代码优化 遇到的问题和解答

 参考地址： https://zhuanlan.zhihu.com/p/106074497

---

## 二、优化事项

### 1. 功能模块降耦合

多态

在程序设计中是一种常用的方法，它的实现方式是先定义一个基类，然后不同的具体实现分别作为它的不同子类存在。在程序运行时执行哪个实现，取决于我们在定义类的对象时用哪个子类做的实例化。

基类RegistrationInterface --> 查看这个的hpp registration_interface.hpp


models

存储匹配和滤波这两个类，以及以后可能新增的通用模块。

### 2. 配置文件

为了方便调试，常用参数写在配置文件里是必须的.

本工程采用yaml格式作为配置文件格式，在程序中，它可以把参数内容对应的放到YAML::Node格式的变量中

前端里程计的配置参数放在config/front_end文件夹下，为了把配置文件内容传入刚才所提到的匹配和滤波两个模块，每个模块均增加一个构造函数，函数参数就是YAML::Node类型，同时基类指针用哪个子类实例化也可以由配置参数决定。